%!
%% fem el cub de Gerrit Noordzij: un cub isomètric, fugant a mestral (NO) construït amb 5 plans quadrats de 5x5 glifs per pla
%% observant el cub original a la portada del llibre «De streek Theorie van het schrift»
%% https://www.typemag.org/images/uploads/Noordzij_Streek_original_cover.jpg
%% podem veure que el tipus utilitzat treballa en 3 eixos dinàmics:
%% a l'eix de les X evoluciona el pes, d'esquerra a dreta, de fina a negreta
%% a l'eix de les y evoluciona la serifa, de dalt a baix, de punxa a escapçat
%% a l'eix de les Z evoluciona el contrast, de davant a darrera (fugant cap el NO) de menys contrast a més contrast

%% per clonar-ho hauríem de localitzar una tipografia que tingués aquests 3 eixos dinàmics (pes, serifa, contrast)
%% quan traslladem el codi a JS/canvas, CSS, html ho tindrem més fàcil

%% però tenim d'altres alternatives:
%% AdobeSans (Serif) MM, sempre el mateix glif, X,Y: pes, Z: ample
%% implementat: en un mateix pla, l'ample es manté i els pesos extrems són al UR (màxim pes) i al LL (mínim pes) 
%% el pes a les columnes ara va de baix a dalt i l'ample va de més estret (primer pla) a més ample (pla final de fuga)
%% les capes són opcionals i descriuen...
%% podríem afegir una anotació sensible a cada glif per fer visible el valor de pes/ample que l'ha generat
%% AdobeSans (Serif) MM, X: pes, Y: sèrie de /ncub glifsi (però mantenint el pes en vertical), Z: ample
%% per implementar
%% AdobeMinion, sempre el mateix glif, X: pes , Y: ample , Z: correcció òptica
%% per implementar

%% definim un seguit de paràmetres dinàmics i activem les lleixes de pdf (Optinal Content)
%% aquest algorisme podria beure de valors aleatoris cada cop que s'executi
%% aquest algorisme és ideal per fer-ne un paral·lel mirall entre l'ús de les MM i les vOTF via js/canvas/CSS/SVG

%% Origin_of_Patterning_LU_OPT.pdf (pàg.233)
%% «The ranges of sort of contrast and reduction of contrast can be set out on
%% dimensions of a cube [...] My description of the cube is a mixture of
%% technology, design, cultural history, and psychology with a flavor of
%% cultural anthropology; a square kind of fortune-telling»
%% Gerrit Noordzij «The Shape of the Stroke» Raster Imaging and Digital Typography
%% (New York: Cambridge University Press, 1991), pp. 34-42 (p.38)
%% https://www.typemag.org/post/it-all-starts-with-writing-gerrit-noordzij

%% generem un espai de coordenades en fals 3D i perspectiva isomètrica (x120 y120 z120)
%% per les limitacions actuals del intèrpret GS, treballem amb tipografies MM
%% escollim un glif
%% generem n graelles de nxn glifs (el cub de Noordzij n val 5)
%% en el pla x,y les caselles s'ordenen de dalt a baix i d'esquerra a dreta
%% a l'eix 2D x,y treballem amb 1 eix dinàmic (p.e. pes o ample)
%% en el pla z les caselles s'ordenen de dreta a esquerra (fuga cap a l'esquerra)
%% a l'eix 3D z treballem amb 1 eix dinàmic (p.e. contrast del ductus o color)
%% cadascun dels plans 3D hauria d'estar en una lleixa
%% el càlcul del format de pàgina hauria d'anar en funció del cos escollit
%% o el cos hauria d'anar en funció del format de pàgina escollit

%% gs -q -dNOSAFER -o re.pdf -sDEVICE=pdfwrite -f Noordzij_cub.ps

%%Assaig del comptador per veure com creix la distribució dins el cub
true
/Acmptdr exch def
%%CUBescriu marcarem els punts on fem ús de l'espai del cub com una manera d'escriure paraules
%% /Acmptdr també ha de ser a true
true
/CUBescriu exch def
(ratassia)  %% paraula que escriurem al cub i el seu nombre de caràcters fixarà el valor del costat
/txtcub exch def

CUBescriu Acmptdr and
{
 txtcub length
}
{  %% escollim el nombre de glifs, ídem pels 3 costats xyz del cub
 3  %% valors enters, de 1 fins a # (quan ncub és > 100 posa a prova les CPU en el càlcul tot i generar un arxiu de pocs Kb)
}ifelse
/ncub exch def


%% escollim un glif pel seu literal, pel seu decimal o una cadena de text?
Acmptdr
{
 ncub dup mul ncub mul
%%CUBescriu marcarem els punts on fem ús de l'espai del cub com una manera d'escriure paraules
 CUBescriu
 {
  %% farcim la cadena on quedaran indexats els glifs que formen la paraula /txtcub per compondre i llegir el cub 3D
  string /txt3Dcub exch def
  /i3Dcub 0 def  %% índex dels glifs a ficar dins /txt3Dcub
  /itxtcub 0 def  %% índex dels glifs a compondre dins /txtcub
  %% escrivint de /txtcub en fuga a Z:
  %% no caldria aquesta nina russa de repeats, doncs amb un for fent salts de length de /txtcub dins /txt3Dcub n'hi hauria prou
%%Ordena de com s'escriu la paraula que hem definit a /txtcub (EP! ara només treballa a 1 octet)
  false
  {
   %% compon el text de manera que, a cada lleixa, componem /txtcub en columna de baix a dalt
   ncub
   {  %% Z
    ncub
    {  %% X
     ncub
     {  %% Y
      i3Dcub dup
      %% primer extraiem el decimal de /txtcub amb l'índex itxtcub
      txtcub itxtcub get
      %% incrustem el decimal a l'índex /i3Dcub dins /txt3Dcub
      txt3Dcub 3 1 roll put
      1 add /i3Dcub exch def
      itxtcub 1 add dup ncub eq
      {  %% inicialitzem l'índex que extrau el glif a compondre
       pop /itxtcub 0 def
      }
      {
       /itxtcub exch def
      }ifelse
     }repeat
    }repeat
   }repeat
  }
  {  %% compon el text de manera que, a cada lleixa, omplim d'1 sola lletra del mot de /txtcub perquè és llegeixi en fuga Z
   /saltLleixa 0 def
   0 1 ncub 1 sub
   {  %% per cada lleixa
    txtcub exch get /araGlif exch def  %% el decimal del glif a repetir per tota la lleixa
    0 1 ncub dup mul 1 sub
    {  %% per tota la lleixa
     saltLleixa add txt3Dcub exch araGlif put
    }for
    saltLleixa ncub dup mul add /saltLleixa exch def
   }for
  }ifelse
%%CUBescriu manualment hi posem el glif que ens sembla que té una mètrica més ample (com ho automatitzarem?)
  (a)
 }
 {
  64 string cvs
 }ifelse
}
{ 
 (e)  %% /e literal  %% 101 decimal  %% (ei) cadena de text
}ifelse
/glif exch def

%% el tractem com el tractem, sempre l'acabem convertint en una string
glif type /integertype eq
{
 1 string dup 0 glif put /glif exch def
}
{
 glif type /nametype eq
 {
  systemdict /EncodingDirectory get /WinAnsiEncoding get /xifrat exch def
  xifrat length 1 sub 0 exch 1 exch
  {
   dup xifrat exch get glif eq
   {
    1 string dup 0 4 -1 roll put /glif exch def exit
   }
   {
    pop
   }ifelse
  }for
  glif type /nametype eq
  {
   (\n\n >>> no hem trobat el glif, pleguem!\n\n)print flush quit
  }if
 }
 {  %% stringtype

 }ifelse
}ifelse


%% escollim un cos
24
/cosglif exch def


%% escollim el format de pàgina
595 842  %% ample, alt
2 array astore /fPagina exch def


%% el format de pàgina en funció del cos (true) o el cos en funció del format de pàgina (false)
true
/paginaVScos exch def  %% aquesta variable encara no actua (fa com si sempre fos a true)


%% activem les lleixes? %%OC Optional Content
true
/FEMlleixes exch def


%% escollim la tipografia MM
(/Users/femfum/MultipleMaster/AdobeSans_AdobeSerif/ZX______.PFB)  %% Terminal
%% ()  %% localhost MacBookAir
%% ()  %% servidor Teixidora
/tipusMM exch def


%% explorem els eixos dinàmics de la MM i els llistem per triar amb quins treballarem
%%MÈTODE0 d'anàlisi dels eixos mestres d'una MM
%% extraiem els valors mínims, intermitjos (si n'hi han) i màxims, de cadascun dels eixos dinàmics de la MM
%% fem un diccionari amb tots els eixos de variabilitat i els seus valors mestres dins una array
/AsansMMeixosDinamics 0 dict def
tipusMM findfont dup /FontInfo get dup /FIMM exch def
/BlendAxisTypes get length 1 sub 0 exch 1 exch
{
 /araEix exch def
 AsansMMeixosDinamics 
 FIMM /BlendAxisTypes get araEix get
 [  %% potser que l'eix de mescla sigui linial entre més de dos valors (p.e. l'eix de correcció òptica segueix aquesta lògica)
  FIMM /BlendDesignMap get araEix get
  {aload pop pop}forall
 ] put
}for
dup length dict begin
{
 1 index /FID ne
 {def}{pop pop}ifelse
}forall
%% atenció que aquesta crida només és vàlida a Ghostscript!
/Encoding systemdict /EncodingDirectory get /WinAnsiEncoding get def  %% xifrat WinAnsi
currentdict end /Camaleonica_WA exch definefont pop
%% mooolt important: carreguem una (1) sola vegada el diccionari genèric ben xifrat de la MM
/Camaleonica_WA findfont /AsansMMionari exch def

%% test/menú
%AsansMMeixosDinamics
%{pop ==}forall
%(!!!!)pstack quit


%% escollim els 2 eixos dinàmics amb els que volem treballar
/Weight  %% pes
/xyeix exch def
/Width  %% ample
/zeix exch def


%% escollim l'orientació (fuga) de la z (true: esquerra, false: dreta)
%% però s'hauria de poder triar entre els 4 vents: NO (mestral), SO (garbí), SE (xaloc) i NE (gregal)
true
/zed exch def


%% calculem el valor de la casella quadrada on pintarem cada glif (en funció del valor màxim de /zeix i /xyeix)
%% fem la instancia, per 1 glif, amb els valors màxims de /zeix i /xyeix
%%MÈTODE1 per generar una instància MM via array del vector, a partir dels valors possibles fixats pel /BlendDesignMap
%% Paul Haahr dóna aquest mètode com més estable...
/unaInstanciaDelAsansMM  %% literal per definir la instància concreta que generem
%% /MinionMM findfont  %% aquí substituïm la crida original pel seu diccionari ja normalitzat a WinAnsi...
AsansMMionari
dup begin  %% entrem dins el diccionari de la MM per poder cridar els procediments NormalizeDesignVector i ConvertDesignVector
[  %% array del vector que treballarà makeblendedfont
 %% el seu ordre (fixat per /BlendAxisTypes) i els seus valors possibles (fixats per /BlendDesignMap)
 %% necessitem obligatòriament tantes dades vàlides com eixos dinàmics de la MM
 %%AdobeSansMM
%%Si fem l'aleatori hauríem de poder establir el valor mínim i el màxim
% realtime srand  %% perquè les 2 crides rand variïn, plantem la llavor de l'aleatori només 1 vegada
% 50 rand 1401 mod add  %% pes: entre 0 i 1400
% 50 rand 1401 mod add  %% ample: entre 0 i 1400

%pop pop [261 228] aload pop  %% un de les millors tries tipogràfiques

%%VALORS EXTREMS de pes i ample (per aquest ordre) de l' AdobeSans MM
 [1450 1450] aload pop  %% tot al màxim
 % [50 1450] aload pop  %% mínim pes màxim ample
 % [1450 50] aload pop  %% màxim pes mínim ample
 % [50 50] aload pop  %% mínim pes mínim ample

%%SNRD pes i ample random o no per aquí mateix de moment (a ús global en d'altres pàgines)
 true setglobal
 2 copy 2 array astore
 globaldict exch
 /ARApesiampleRandomOno exch put
 false setglobal

 %% aquests dos procediments, i per aquest ordre, generen les dades necesàries del vector dins l'array
 NormalizeDesignVector  %% normalitza les dades de cada eix mestre en valors entre 0 i 1
 ConvertDesignVector  %% genera les dades finals pel seu ús dins la matriu de l'array per a makeblendedfont
] end
makeblendedfont
definefont  %% fixem la font en memòria
dup
%% calculem el % de l'ascendent/descendent d'aquesta instància per tal de situar bé la línia de base en relació a ?
/FontBBox get dup 1 get abs dup 3 -1 roll 3 get add exch 100 mul exch div dup /AsansMMx100descendent exch def
100 exch sub /AsansMMx100asdescendent exch def
/instantMAX exch def  %% diccionari de la instància amb els seus valors màxims


%% generem l'array tridimensional de valors de pes/ample que alimentarà el generador d'instàncies
/ii 0 def  %% comptador d'instàncies per personalitzar-ne el nom
%% calculem el salt de l'ample (max - min : /ncub)
AsansMMeixosDinamics zeix get aload pop exch sub ncub 1 sub div /saltZeix exch def
1450 /maxAMPLE exch def  50 /minAMPLE exch def  %% valors màxim i mínim d'ample

%% calculem el salt del pes ((max - min : /ncub x /ncub)
AsansMMeixosDinamics xyeix get aload pop exch sub ncub dup mul 1 sub div /saltXYeix exch def
1450 /maxPES exch def  50 /minPES exch def  %% valors màxim i mínim de pes

%% la descripció que fem és pel cub clàssic de 5x5 (però no pas la funcionalitat)
true setglobal  %% no sabem si és del tot imprescindible
[  %% conté tants arrays com /ncub

%%Ordena l'eix Z (fuga) del cub
true /Ofuga exch def
Ofuga
{
 ncub 1 sub -1 0  %% comença amb els glifs més estrets al davant (primer pla del cub)
}
{
 0 1 ncub 1 sub  %% comença amb els glifs més amples al davant (primer pla del cub)
}
ifelse

 {  %% for per a cadascun dels amples (1 per pla)
  %% els amples (índex 1) només canvien 5 cops (un per cada pla) d'estreta a ample, del fons al primer pla
  %% EP! però l'índex va de 4 a 0, o sigui que a 4 hi haurà d'anar el valor més estret i a zero el valor més ample  
  saltZeix mul maxAMPLE exch sub round cvi /araPLAample exch def  %% ha de ser un valor enter!
  [  %% obrim pla
   /araPES 0 def
   ncub
   {  %% repeat de 5 columnes per pla
    %% l'índex va de 0 a 4 perquè les columnes van d'esquerra a dreta
    [  %% obrim columna
     0 1 ncub 1 sub
     {  %% for els pesos (índex 0) canvien 25 cops per pla (5 per cada columna) de fina a negreta
      [  %% cada glif amb la seva instància, 5 glifs d'1 columna
       exch saltXYeix mul maxPES exch sub round cvi  %% pes
       %% l'índex va de 4 a 0 perquè els glifs van de dalt a baix, o sigui a 4 hi ha d'anar el valor més fi i a 0 el més negret
       araPLAample  %% ample
      ]  %% cada glif amb la seva instància
     }for
     %% aquí hem de desar el darrer valor de l'ample per la següent columna
     dup 0 get saltXYeix sub /maxPES exch def

%%Ordena els glifs de la columna, true: el de més pes a dalt | false: el de menys pes a dalt
true
{
  %% aquest loop capgira tots els elements trobats a la pila
  counttomark dup 1 gt
  {  %% capgirem sempre que hi hagi més d'un paquet
   /atura't exch def
   /ici 2 def
   {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
   %% NO ens carreguem la mark
   % atura't 1 add -1 roll pop
  }
  {
   pop exch pop /atura't 1 def
  } ifelse
}if

    ]  %% tanquem columna

   }repeat

   %% aquí hem de incialitzar cap valor?
   1450 /maxPES exch def

%%Ordena les columnes, true: la de més pes a la dreta del pla | false: la de menys a la dreta del pla
false
{
  %% aquest loop capgira tots els elements trobats a la pila
  counttomark dup 1 gt
  {  %% capgirem sempre que hi hagi més d'un paquet
   /atura't exch def
   /ici 2 def
   {ici -1 roll ici 1 add /ici exch def ici atura't gt {exit} if} loop
   %% NO ens carreguem la mark
   % atura't 1 add -1 roll pop
  }
  {
   pop exch pop /atura't 1 def
  } ifelse
}if

  ]  %% tanquem pla
 }for  %% per a cadascun dels amples (1 per pla)
]

%% podem ajustar a cada pla el pes del darrer glif de la darrera columna --l'índex 0 a /minPES-- per corregir la desviació d'1
%dup
%{  %% per cada pla
% dup length 1 sub get  %% la darrera columna
% dup length 1 sub get  %% el darrer glif
% 0 minPES put
%}forall

%%TEST
%dup == quit

globaldict exch  %% no sabem si és del tot imprescindible
/Ainstancies exch put  %% totes les instàncies del cub de Noordzij
false setglobal

gsave
%% mètode stringwidth
%0 0 moveto glif tipusMM cosglif selectfont stringwidth pop
%% mètode bbox
gsave
%% llegim les coordenades del rectangle que inscriu el glif (bounding box), ignorant els nodes de control
0 0 moveto
%% tipusMM cosglif selectfont

%% activem la instància amb els seus valors màxims per fer el càlcul de la casella que les contindrà totes
instantMAX cosglif scalefont setfont

glif  %% el caràcter dins una string
true charpath flattenpath pathbbox
%% avaluem el rectangle pur
3 -1 roll abs add  %% altura Y
3 1 roll exch abs add  %% amplada X
2 copy gt
{
 pop
}
{
 exch pop
}ifelse

%% si no li posem, si el glif no tingués variabilitat (cos/pes/ample) es tocarien pels 4 costats
%false
%{
%% li sumem un #% de marges dins la casella (la meitat d'aquest valor és el marge que envoltarà el glif)
dup 10  %% #% com és alt menys marge i més petit serà el format de pàgina (s'afegeix al cos del glif)
div add
grestore
%}if
/casellag exch def  %% afecta a la mida del glif dins la casella!

%% fixem els graus de la projecció (perspectiva)
30  %% 30º per la isomètrica (imprescindible a 30 si volem emular el cub de Noordzij)
/geixos exch def


%% valor de la tangent ideal per la isomètrica: és un multiplicador del valor del costat Y del quadrat de la lleixa
geixos sin geixos cos div  %% valor de la tangent de l'angle /geixos (30ª) per l'eix X de la isomètrica
/Ti exch def
%%valor de la hipotenusa X que cal que la Y iguali
casellag ncub mul dup dup mul exch Ti mul dup mul add sqrt /hY exch def


%% igualem les mides dels dos eixos? (un cop en perspectiva l'eix X és més llarg que l'eix Y)
true
/iS exch def  %% imprescindible a true si volem emular el cub de Norrdzij


%% comptador per avaluar l'ordre d'escriptura dels glifs
Acmptdr
{
 /ioe 0 def
}if


[  %% generem la matriu tridimensional (/ncub valors de Z)
 %% posicionaríem i generaríem cadascun dels plans xy
 %% 0 1 ncub 1 sub  %%EP! el cub fuga cap al SE (xaloc) però s'han de tocar d'altres coses per tal quadri amb el format de pàgina
 ncub 1 sub -1 0  %% el cub fuga cap al NO (mestral) tal i com el va concebre Noordzij
 {  %% for que genera els valors de cadascun dels plans xy en un sentit de fuga

  dup /iApla exch def  %% útil per etiquetar les lleixes?

%%Hi pesquem l'índex de 4 a 0 de l'array de plans verticals pel grup de 5x5 glifs que pintaran el pla actual
  dup Ainstancies
  exch get

%%FEM únic el nom de la variable
%1 index dup /iApla exch def 64 string cvs dup length 1 add string dup 0 (A) putinterval dup 3 -1 roll 1 exch putinterval
%cvn exch def

%%Astack
%true setglobal
%globaldict exch
%dup length array copy
%(0000)pstack quit
/Apla exch def
%false setglobal

  [
%%Astack
%(1111)pstack quit
   exch
%3 -1 roll

   [  %% pla del cub, sigui virtual, ple, perfilat o retallador
    exch
    casellag mul casellag ncub mul  %% test 
    zed
    {
     exch dup neg exch 3 -1 roll dup
    }
    {
     exch dup 3 -1 roll dup
    }ifelse
   ]  

%%Astack
%% string com a proc
(
%   {  %% proc dels glifs

    Acmptdr
    {
     %% test de lateralitat
     /lat true def
    }if

    0 1 ncub 1 sub  %% fa les columnes d'esquerra a dreta
    % ncub 1 sub -1 0  %% fa les columnes de dreta a esquerra
    {  %% for que situa la columna d'instàncies al seu lloc

%%Hi pesquem l'índex de 0 a 4 de l'array de pesos/amples pel grup de 5 glifs que pintaran la columna actual
     dup

)
%%Astack

%%Astack
     Apla  %% pla vertical del cub

%%Astack
 %% cap de l'array del pla
 exch dup length dup /ARAva exch def 2 add string dup 3 -1 roll 0 exch putinterval
 dup ARAva ([\n) putinterval exch

{  %% forall de la primera array

 %% cap de l'array de columna
 exch dup length dup /ARAva exch def 2 add string dup 3 -1 roll 0 exch putinterval
 dup ARAva ([\n) putinterval exch

 {  %% forall de la segona array

  %% cap de l'array de valors
  exch dup length dup /ARAva exch def 2 add string dup 3 -1 roll 0 exch putinterval
  dup ARAva ([\n) putinterval exch

  {  %% forall de l'array de valors
   %% passem a string el primer valor
   64 string cvs dup length dup /ARAva exch def 1 add string dup 3 -1 roll 0 exch putinterval
   dup ARAva ( ) putinterval
   %% encadenem el primer valor
   dup length 2 index length dup /ARAva0 exch def add dup /ARAva1 exch def string dup 4 -1 roll 0 exch putinterval
   dup 3 -1 roll ARAva0 exch putinterval
  }forall

  %% cua de l'array de valors
  dup length dup /ARAva exch def 2 add string dup 3 -1 roll 0 exch putinterval
  dup ARAva (]\n) putinterval

 }forall

 %% cua de l'array de columna
 dup length dup /ARAva exch def 2 add string dup 3 -1 roll 0 exch putinterval
 dup ARAva (]\n) putinterval

}forall

%% cua de l'array del pla
dup length dup /ARAva exch def 2 add string dup 3 -1 roll 0 exch putinterval
dup ARAva (]\n) putinterval


%%Astack
(

%iApla 64 string cvs dup length 1 add string dup 0 (A) putinterval dup 3 -1 roll 1 exch putinterval
%dup ==
%cvx exec % (kkkkk)pstack quit

     exch get

dup length array copy
%dup ==

%%Astack
     /Acolumna exch def  %% l'array amb la columna

     gsave
     casellag mul 0 translate

      0 1 ncub 1 sub  %% pinta els glifs de baix a dalt
     % ncub 1 sub -1 0  %% pinta els glifs de dalt a baix
     {  %% for que genera una instància cada vegada i pinta el(s) glif(s)
      gsave

%%Hi pesquem l'índex de 4 a 0 dins l'array de pesos/amples del glif que es pinta a la columna de dalt a baix
     dup

%%Astack
     Acolumna

     dup length array copy exch get
%%Profilaxi?
%dup length array copy
% dup ==

%%Aquí generem la instància
%%MÈTODE1 per generar una instància MM via array del vector, a partir dels valors possibles fixats pel /BlendDesignMap
%% Paul Haahr dóna aquest mètode com més estable...

%%Haurem de generar un nom únic?
/unaInstanciaDelAsansMM  %% literal per definir la instància concreta que generem
%ii 64 string cvs cvn
ii 1 add /ii exch def

%% aquí substituïm la crida original pel seu diccionari ja normalitzat a WinAnsi...
AsansMMionari
dup begin  %% entrem dins el diccionari de la MM per poder cridar els procediments NormalizeDesignVector i ConvertDesignVector
[  %% array del vector que treballarà makeblendedfont
 %% el seu ordre (fixat per /BlendAxisTypes) i els seus valors possibles (fixats per /BlendDesignMap)
 %% necessitem obligatòriament tantes dades vàlides com eixos dinàmics de la MM

 4 -1 roll

%%TEST
%dup length array copy dup ==

 aload pop  %% despleguem els valors de la instància

%%SNRD pes i ample random o no per aquí mateix de moment (a ús global en d'altres pàgines)
% true setglobal
% 2 copy 2 array astore
% globaldict exch
% /ARApesiampleRandomOno exch put
% false setglobal

 %% aquests dos procediments, i per aquest ordre, generen les dades necesàries del vector dins l'array
 NormalizeDesignVector  %% normalitza les dades de cada eix mestre en valors entre 0 i 1
 ConvertDesignVector  %% genera les dades finals pel seu ús dins la matriu de l'array per a makeblendedfont
] end
makeblendedfont
definefont  %% fixem la font en memòria

%%TEST
%dup length dict copy

      cosglif scalefont setfont


      %% fem una roda de color per comprovar que l'ordre és el què voldrem per les instàncies?
      false
      {
       lat
       {
        /lat false def
        0 1 1 setrgbcolor
       }
       {  %%EP! nomès vàlid si fem el cub de 5x5
        [ [ 0 0 0] [ 1 0 0] [ 0 1 0] [ 0 0 1] [ 1 1 0] ]
        1 index get aload pop setrgbcolor
       }ifelse
      }
      {  %% color dels glifs
       0 0 0 setrgbcolor
      }ifelse

      %% càlcul per centrar el glif dins la casella quadrada
      gsave
      %% llegim les coordenades del rectangle que inscriu el glif (bounding box), ignorant els nodes de control
      0 0 moveto
      glif  %% el caràcter dins una string
      true charpath flattenpath pathbbox

      %% avaluem el rectangle pur
      4 copy
      3 -1 roll abs add  %% altura Y
      3 1 roll exch abs add  %% amplada X

      %% marges X del rectangle pur vs casella
      casellag exch sub exch
      %% marges Y del rectangle pur vs casella
      hY ncub div dup /YsaltCasella exch def  %cosglif
      exch sub
      %% calculem l'orígen per tal quedi centrat dins la casella
      2 div 5 -1 roll sub  %% origen Y
      exch 2 div
      5 -1 roll
      %% quid del centrat!
      pop  %% origen X 

      grestore

      exch 5 -1 roll YsaltCasella mul add

%%TEST cap del posicionat net de cada glif en relació al punt 0,0 absolut
%ii 1 eq  %% en fem només 1
true  %% a tot
{  %% cal posar ordre a les coordenades
% gsave dup 0 2 getinterval dup == aload pop transform itransform == == grestore 
% ii ==

%% corregim l'ordre de les coordenades per tal que la casella quadri amb el glif
4 copy 3 -1 roll 4 -1 roll exch
%% com que no és format rectstroke li hem de donar format bbox
2 index add exch 3 index add exch
4 array astore

%% fem un nom únic
%%EP! hauríem de pescar els pesos i amples de cada lleixa en una array desada a banda dins la memòria global
(Weight: ### Width: ### glif000) dup ii 64 string cvs dup length 3 exch sub 27 add exch putinterval /araTooltip exch def

%%Constatem amb alegria que els articles obeeixen al mateix sistema de coordenades amb el que componem els glifs
%% cosa que no fan d'altres objectes del pla interactiu de pdf, com les anotacions o els formularis (les descartem aquí)
%% tenen en comú però que tampoc NO obeeixen els Optional Contents, o sigui que ignoren les capes
%% amb l'avantatge de comptar amb una solapa pròpia de navegació ens permetrà localitzar els pesos clicant sobre el glif
%% poser hauríem d'obrir el PDF amb aqusta la solapa activa més que amb le de les capes
%% el viewer de PDF a Firefox: TÉ la solapa de capes i funciona, també podem veure la solapa d'articles però els links no van
%% el viewer de PDF a Brave/Chrome: NO té la solapa de capes, té la solapa d'articles però els links no van
[
/Rect 3 -1 roll
%dup ==
/Title araTooltip
/Page 1
/ARTICLE
pdfmark

[
/Action /Article
/Dest araTooltip
/Title araTooltip
/OUT pdfmark


false{
%%Awidget
%% aquí hi poden anar les Annots?
[
/_objdef
({tooltipUNIC000}) dup ii 64 string cvs dup length 3 exch sub 12 add exch putinterval
dup /araTooltip exch def cvx exec
/type /dict
/OBJ pdfmark
%% si volem visibilitzar gràficament el rectangle
%gsave 1 0 0 setrgbcolor 0 setlinewidth 4 copy 3 -1 roll 4 -1 roll exch rectstroke grestore
%% caldrà veure si les anotacions també queden amagades sota la perspectiva de les capes
%% corregim l'ordre de les coordenades per tal que la casella quadri amb el glif
4 copy 3 -1 roll 4 -1 roll exch
%% com que no és format rectstroke li hem de donar format bbox
2 index add exch 3 index add exch
4 array astore

mark
{tooltips}
araTooltip cvx exec
mark
araTooltip cvx exec

false
{
 <<
   /Rect 8 -1 roll  % rectangle invisible i sensible del botó
%(Y)pstack quit
   /P {ThisPage}  % ref ind a l'entrada que hi ha d'haver al diccionari de la pàgina
   /FT /Btn  % tipus botó
   /T (BotoPostIt)  % nom intern pot ser ídem per tots?
   /Ff 65536  % flag obligatori per al tipus botó
   /Subtype /Widget  % obligatori
   /Type /Annot  % obligatori
   /TU (tampoc al GSoC!)  % text del Tooltip (Sticky Note o Post-It)
 >>
}
{
 <<
   /Rect 8 -1 roll 
   /P {ThisPage}
   /FT /Btn
   /T %(elMeuTooltip)
araTooltip
   /Ff 65536
   /Subtype /Widget
   /Type /Annot
   /TU (Weight: 50 | Width: 1450)
   /F 4
   /AA <<>>
   /MK <</IF <<>> >>
   /H /N
   /DA (/HeBo 18 Tf 0 g)
 >>
}ifelse

/PUT
pdfmark

/APPEND
pdfmark

%%TEST cua
}if
}if

      moveto pop pop

      Acmptdr
      {  %% escriu el nombre del comptador
       CUBescriu
       {  %% extraiem el glif que toca compondre 
        txt3Dcub ioe 1 getinterval
        ioe 1 add /ioe exch def
       }
       {
        ioe 64 string cvs ioe 1 add /ioe exch def
       }ifelse
      }
      {  %% escriu el glif
       glif
      }ifelse

      show  % glyphshow
      grestore
     }for  %% genera una instància cada vegada i pinta el(s) glif(s)

     grestore
    }for  %% situa la columna d'instàncies al seu lloc

%%Astack
)
%% string com a proc
%   }

%%Astack
%% empalmem 2 strings
dup length exch 3 -1 roll dup length dup /ARAva exch def 4 -1 roll
add string dup 3 -1 roll 0 exch putinterval dup ARAva 4 -1 roll putinterval

  ]
 }for  %% genera els valors de cadascun dels plans xy en un sentit de fuga
]  %% matriu tridimensional (/ncub valors de Z)

%dup ==

%% el format de pàgina exacte seria, tenint en compte la perspectiva:
%% per la Y, els valors transformats de la primera lleixa, sumant el valor Y del punt UR i el valor Y del punt LL
%% mètode via transform/itransform
gsave
dup 0 get 0 get
[  %% posem en perspectiva l'eix X amb el valor de la tangent /Ti de /geixos graus
 1

 Ti
 % geixos sin geixos cos div  %% valor de la tangent de l'angle /geixos (30ª) per l'eix X de la isomètrica
 %  0  %% test

 0 1 0 0
] concat
aload pop pop hY
transform  %% dóna les coordenades del punt x,y (eix normal) en unitats del dispositiu de sortida (device pixels)
2 array astore 3 1 roll
transform
grestore
itransform  %% dóna les coordenades del punt x,y (eix normal) en punts tipogràfics
exch pop  %% conservem el valor de Y
exch aload pop itransform
exch pop add  %% valor net de Y que dóna l'altura exacta del cub en perspectiva
/cNy exch def  %% distància Y (valor Y del cub de Noordzij)
%% per la X (la perspectiva no l'afecta) la distància X entre la posició LL de la primera lleixa i la posició LR de la darrera
dup 0 get 0 get 0 get abs  %% LL
1 index ncub 1 sub get 0 get 2 get  %% LR
add /cNx exch def  %% distància X (valor X del cub de Noordzij)

%% definim els 4 marges de posicionament del cub a dins la pàgina
50
/mep exch def

%% definim la pàgina
<</PageSize[ cNx mep 2 mul add cNy mep 2 mul add ]>>setpagedevice

%%OC cap
FEMlleixes
{
%%+ LA CREACIÓ DELS OBJECTES ESTRUCTURALS DELS OPTIONAL CONTENTS QUE S'HAN DE GENERAR NOMÉS 1 COP S'HAURIEN DE DEFINIR AQUÍ
%%+ aquí creem els objectes OC del Catalog que cal fer créixer
 mark /_objdef {objCatalog} /type/dict /OBJ pdfmark  %% l'objecte diccionari a afegir a {Catalog}
 mark /_objdef {objOCProperties} /type/dict /OBJ pdfmark  %% l'objecte diccionari a afegir a {objCatalog}
 mark /_objdef {objD} /type/dict /OBJ pdfmark  %% l'objecte diccionari a afegir a {objOCProperties}
 mark /_objdef {objOCGs} /type/array /OBJ pdfmark  %% l'objecte array a afegir a {objOCProperties}
 mark {objD} << /BaseState /ON >> /PUT pdfmark  %% afegim una clau/valor fix a {objD}
 mark {objD} << /ListMode /VisiblePages >> /PUT pdfmark  %% afegim una clau/valor fix a {objD}
 mark /_objdef {objOrder} /type/array /OBJ pdfmark  %% l'objecte array de la clau /Order a afegir a {objD}
%%Només l'inicialitzem un cop?
 /iL 0 def  %% comptador de layers

%%+ comprovarem si al generador de capes l'ordre dels factor no altera el producte
 /lleiXes 1 dict def  %% inicialitzem on desarem objectes i noms de capes pel pdfmark i per pàgina

%%Awidget
false{
 %% estructura d'objectes de l'arbre Acroform que penja del Catalog per generar els tooltips amb els valors de cada glif
 [ /_objdef {aform} /type /dict /OBJ pdfmark
 [ /_objdef {afields} /type /array /OBJ pdfmark
 [ {aform} << /Fields {afields}
/DR <<
%      /Font <</ZaDb 11 0 R /Helv 10 0 R /HeBo 38 0 R >>
%      /Encoding <</PDFDocEncoding 12 0 R >>
    >>
/DA (/Helv 0 Tf 0 g )
           >> /PUT pdfmark
 [ {Catalog} << /AcroForm {aform} >> /PUT pdfmark
 [ {afields} {tooltips} /APPEND pdfmark

%% entrada /Annots com una array del diccionari /Page on hi ficarem tots els tooltips
 [ /_objdef {tooltips} /type /array /OBJ pdfmark
 [ {ThisPage} << /Annots {tooltips} >> /PUT pdfmark
}if

}if


%% segons els marges /mep posicionem el cub dins la pàgina
zed
{
 ncub 1 sub
 casellag mul mep add
 mep

%%TEST
%2 copy 2 array astore ==

 translate
}if

%% array on desarem els valors Z de les lleixes
/Zlleixes ncub array def

%% executem la matriu tridimensional
{  %% forall per tots els plans verticals

 %% aquì podríem definir una lleixa per cada pla vertical del cub
%%OC per cada pla vertical
 FEMlleixes
 {
%%+ generador de capes
%% crides pdfmark de configuració de capes
%% les declarem i les hi donem nom literari
  /araOLl ({objecteNodeLleixa) def
  /araNLl (nomNodeLleixa) def
  (}) araOLl dup length dup /araVa exch def string copy iL 6 string cvs dup length dup
  /aCua exch def 1 add araVa add string dup 4 -1 roll 0 exch putinterval dup 3 -1 roll araVa
  exch putinterval dup 3 -1 roll araVa aCua add exch putinterval dup length string copy /araOLl exch def

%(CAL?)pstack quit
%        dup 1 get ARAupath exch 2 sub get  %% la X del node
%        exch 0 get dup 3 1 roll  %% pel nom de la layer

%%+ aquí és on creem la capa
  mark /OC araOLl cvx exec /BDC pdfmark
%        gsave 0 1 0 setrgbcolor faX grestore
 }if  %%OC fem lleixes

 dup 0 get

 %% extraiem el punt 0,0 per moure la lleixa de les lletres al pla corresponent
 dup 0 2 getinterval 3 1 roll

 gsave

 iS  %% refusem fer servir cap escalat
 {  %% igualem les mides dels 2 eixos?
%  1 1.2 scale  %% càcul a ull, però s'ha de fer ben fet
 }if

 [  %% posem en perspectiva l'eix X a /geixos (30 graus?)
  1

  Ti
% geixos sin geixos cos div  %% valor de la tangent de l'angle /geixos (30ª) per l'eix X de la isomètrica
%  0  %% test

  0 1 0 0
 ] concat

%%TEST que ens marca el filet del pla vertical
 gsave
false{
 gsave
 dup 1 setlinewidth 1 0 0 setrgbcolor
 %% perfilem les lleixes?
 %% rectifiquem la Y per igualar els dos costats per la distorsió de la perspectiva
 aload pop pop hY rectstroke
 grestore
}if

 %% tapem o no les lleixes verticals?
 %pop
 %% rectifiquem la Y per igualar els dos costats per la distorsió de la perspectiva
 aload pop pop hY
 1 1 1 setrgbcolor rectfill
 grestore

 1 get

 %% movem la lleixa de les lletres al seu pla
 exch aload pop translate

%(!)pstack quit
%dup length 20 sub 20 getinterval (AESCRIURE)pstack quit

 cvx exec  %% executem l'string com a proc dels glifs

 grestore

%exit  %% test per si només volem veure la primera lleixa

%%OC per cada pla vertical
 FEMlleixes
 {
%%+ aquí és on tanquem la capa
  mark /EMC pdfmark

%%+ generador de capes
%% crides pdfmark de configuració de capes
%% les declarem i les hi donem nom literari
%%+ aquí podem diferir el farcit a string i desar-ho dins una array de 2 elements (ens interessa per facilitar la categorització)
%BlueO 64 string cvs dup length /araVa exch def exch 64 string cvs dup length araVa add 3 add string dup
%4 -1 roll 0 exch putinterval dup araVa ( / ) putinterval dup 3 -1 roll araVa 3 add exch putinterval
%dup length string copy

%%EP! hauríem de pescar els amples de cada lleixa en una array desada a banda dins la memòria global
%Apla iApla get 0 get 1 get  %% aquest no canvia mai
Ofuga
{
 maxAMPLE iApla saltZeix mul sub cvi  %% comença amb els glifs més estrets al davant (primer pla del cub)
}
{
 minAMPLE iApla saltZeix mul add cvi  %% comença amb els glifs més amples al davant (primer pla del cub)
}ifelse
%(LLLL)pstack quit
%(###)  %% valor genèric provisional
zeix 128 string cvs dup length dup /ARAva exch def
2 index 128 string cvs length add 1 add string dup 3 -1 roll 0 exch putinterval
dup ARAva ( ) putinterval dup 3 -1 roll 128 string cvs ARAva 1 add exch putinterval
iApla 1 add /iApla exch def  %% si canviessim la fuga (ara al NO) això s'invalida!

  [
   exch
   iL  % BlueO
   exch
  ]
  /nomLleixa exch def
%%+ generador de capes
%% desem 
  lleiXes araOLl
  [
   nomLleixa
   %% definim el nom intern de la lleixa
   araNLl dup length dup /araVa exch def string copy iL 6 string cvs dup length araVa add string dup
   4 -1 roll 0 exch putinterval dup 3 -1 roll araVa exch putinterval cvn
   %% flag del node que NO balla
   true  % BVoOB
   {  %% si és BlueValues
    0
   }
   {  %% si és OtherBlues
    2
   }ifelse
  ] put

  iL 1 add /iL exch def

 }if  %%OC tanquem la capa

%% ordenem el valor constant de Z
Zlleixes Acolumna 0 get 1 get iL 1 sub exch put

}forall  %% per tots els plans verticals


%%OC cua
FEMlleixes
{
%%+ arbre estructural de les capes
%%+ creem els objectes per l'OptionalContent
 lleiXes
 {
  pop mark /_objdef 3 -1 roll 128 string cvs cvx exec /type/dict /OBJ pdfmark
 }forall

 lleiXes
 {  %% forall
  exch mark exch 128 string cvs cvx exec
  <<
    /Type /OCG
%%+ aquí definim el nom literari (solapa) de la lleixa muntant l'string amb el (Y del Blue / Y del node)
    /Name 7 -1 roll dup 0 get
    dup length 2 eq
    {  %% és un node
     exch pop aload pop exch 64 string cvs dup length /araVa exch def exch 64 string cvs dup
     length araVa add 3 add string dup 4 -1 roll 0 exch putinterval dup araVa ( / ) putinterval
     dup 3 -1 roll araVa 3 add exch putinterval dup length string copy
    }
    {  %% és una zona BlueValues o OtherBlues
     0 get 64 string cvs dup length /araVa exch def exch 2 get 4 eq
     {
      ( > BlueValue) dup length araVa add string dup 3 -1 roll araVa exch putinterval dup 3 -1 roll 0 exch putinterval
     }
     {
      ( > OtherBlue) dup length araVa add string dup 3 -1 roll araVa exch putinterval dup 3 -1 roll 0 exch putinterval
     }ifelse
    }ifelse
  >> /PUT pdfmark
 }forall

 %% configurem el seu comportament (ordre, visibilitat, impressió, etc)

%%+ alimentem l'array objGlif sempre amb nom diferent
 /araOG ({objGlif) def
 (}) araOG dup length dup /araVa exch def string copy
 %iOG
 iL
 6 string cvs dup length dup
 /aCua exch def 1 add araVa add string dup 4 -1 roll 0 exch putinterval dup 3 -1 roll araVa
 exch putinterval dup 3 -1 roll araVa aCua add exch putinterval dup length string copy /araOG exch def

 mark /_objdef araOG cvx exec /type/array /OBJ pdfmark  %% l'objecte array es crea per cada glif a afegir a {objOrder}

 mark araOG cvx exec
 %GLiF
 (Cub de Noordzij)
 128 string cvs dup length dup /araVa exch def 4 add dup /araVa2 exch def
 %ffile
 glif 128 string cvs
 length add
 dup /araVa3 exch def 1 add string dup 3 -1 roll 0 exch putinterval dup araVa (   {) putinterval dup araVa2
 % ffile
 glif 128 string cvs
 putinterval
 dup araVa3 (}) putinterval
 /APPEND pdfmark  %% afegim el nom del glif i del fitxer de la font a l'objecte array

 mark araOG cvx exec

%lleiXes {== ==}forall (----)== quit
 [
  (Y BlueValues:)
  %% primer anem a pescar les zones
  lleiXes
  {
   2 get 4 eq
   {
    128 string cvs cvx exec
   }
   {
    pop
   }ifelse
  }forall
  [
   (Y Nodes:)
   %% anem a pescar els nodes dels BlueValues
   lleiXes
   {
    dup 2 get 0 eq
    {
     pop 128 string cvs cvx exec
    }
    {
     2 get 1 eq
     {
      128 string cvs cvx exec
     }
     {
      pop
     }ifelse
    }ifelse
   }forall

  ]


%%TEST
%Zlleixes
%(zzzz)pstack quit
cleartomark
mark
lleiXes
{
 pop 128 string cvs
}forall
%% endreça una seqüència numèrica o de text, existent a l'stack, de menys a més (operador ge) o de més a menys (operador le)
%% a comptar des de la base de l'stack  
{  %% loop mentre estiguin desordenats
 counttomark 1 sub /iCul exch def
 %% escombrat d'ordenació
 iCul     
 {  %% repeat 
  iCul index /araCul exch def
  iCul 1 sub index araCul ge  %% ordre d'endreça
  {     
   iCul 1 sub /iCul exch def
  }          
  {
   iCul -1 roll
   iCul 1 add 1 roll
  }ifelse
 }repeat
 %% mirem si estan per ordre de menys a més (ge)
 %% o de més a menys (le), començant pel cul de l'stack
 /Ordenats true def 
 counttomark 1 sub /iCul exch def
 iCul
 {  %% repeat
  iCul index /araCul exch def
  iCul 1 sub index araCul ge  %% ordre d'endreça
  {
   iCul 1 sub /iCul exch def
  }
  {
   /Ordenats false def
   exit
  }ifelse
 }repeat
 Ordenats{exit}if
}loop

counttomark array astore

(lleixes verticals)
exch
{
% lleiXes exch get
 cvx exec
}forall

%exch pop aload pop exch

 ] /APPEND pdfmark  %% afegim els BlueValues amb els seus Y nodes a l'objecte array

%%+ alimentem l'array objOrder
 mark {objOrder} araOG cvx exec /APPEND pdfmark  %% afegim l'array {objGlif} a l'array {objOrder} 

%%+ alimentem l'array objOCGs de forma que anem afegint els objectes a la cua 
 lleiXes
 {  %% els objectes de capa no tenen cap necessitat d'anar ordenats segons el glif/pagina corresponent
  pop 128 string cvs cvx exec mark exch {objOCGs} exch /APPEND pdfmark
 }forall

 %% integració a la base de l'estructura de pàgina
 mark {ThisPage}
 <<
   /Properties
   <<
     %% clau (nom intern de la lleixa) valor (objecte de la lleixa)
     lleiXes
     {
      1 get exch 128 string cvs cvx exec
     }forall
   >>
 >> /PUT pdfmark

%%+ cal veure si aquí és on ens cal desar 1 COP els cobjectes de l'estructura de lleixes que aguanten l'arbre OCProperties
%%+ només 1 COP al final
%%+ alimentem el diccionari objD
 mark {objD} << /Order {objOrder} >> /PUT pdfmark  %% afegim {objOrder} a {objD}

%%+ només 1 COP al final
%%+ alimentem el diccionari objOCProperties
 mark {objOCProperties} << /OCGs {objOCGs} /D {objD} >> /PUT pdfmark

%%+ només 1 COP al final
%%+ finalment alimentem el diccionari Catalog
 mark {Catalog} << /OCProperties {objOCProperties} >> /PUT pdfmark

}if

mark
%% camps públics del Docinfo
/Subject
(generem dinàmicament l'icònic cub de Gerrit Noordzij)
/Title
(GerritNoordzijCub_#.pdf)
/Author (copyleft 2023: Marcantoni Malagarriga-Picas <marcantoni@femfum.com>)
/Keywords (PostScript, Ghostscript, MultipleMaster, PDF, Optional Content, generative code, typography, Gerrit Noordzij, https://ja.cat/NoordzijCub)
/Creator (https://github.com/marcantonifemfum/CubNoordzij/blob/main/Noordzij_cub.ps)
/DOCINFO pdfmark
%% podríem generar un camp privat per desar-hi tots els paràmetres clau de les variables aleatòries que han fet el PDF

showpage

